# Mensajes en español para Based CLISP 2.49.60.
# Copyright (C) 1996 Free Software Foundation, Inc.
# This file is distributed under the same license as the clisp package.
# Carlos Linares López <clinares@delicias.dia.fi.upm.es>, 1997.
# Santiago Vila Doncel
# Leonardo Sarasúa García
# Han contribuido a esta traducción:
# cll - Carlos Linares López 	(Traducción)
# sv  - Santiago Vila Doncel	(Revisión)
# lsg - Leonardo Sarasúa García	(Traducción y Revisión)
# Agradecimientos especiales a:
# Bruno Haible
# Marcus Daniels	(Programadores de CLisp)
# Enrique Melero	(Coordinador de Spanish GNU)
# Por haber atendido siempre mis preguntas y por mostrar tanto interés
# en esta traducción.
# Muchísimas gracias, Leo. Te debo la cerveza más grande del mundo, ...
# Asimismo, quisiera expresar mi agradecimiento a las siguientes
# personas, por responder pacientemente todas mis preguntas: Joerg
# Hoehle (traductor de la versión francesa) y Juan Jordana.
# Por último, a toda la lista de Spanish GNU Translation Team
# (es@es.li.org) por sus sugerencias.
# NOTAS.
# * Los mensajes en los que se han realizado anotaciones de interés,
# bien porque haya alguna duda, bien porque contenga notas importantes
# relativas a las traducciones tienen la palabra `Duda:' al principio de
# su comentario.
# * Por favor, si alguien realiza alguna modificación a este archivo que
# ponga sus iniciales al final del comentario explicando el cambio y el
# motivo. Si su nombre no está en esta cabecera que lo añada poniendo
# las iniciales.
# * Todas las líneas que comienzan con #~S son mensajes obsoletos que no
# hace falta revisar. En cualquier caso, intentaré normalmente
# eliminarlas.
# Revision 1.25  2007/10/12 19:24:51  sds
# regenerated for 2.41.1 pretest
# Revision 1.24  2006/10/13 04:10:53  sds
# clisp 2.41 release (Friday the 13th!)
# Revision 1.23  2006/10/01 16:13:06  sds
# regenerated for 2.40 (2006-09-23)
# Revision 1.22  2006/07/14 15:45:47  sds
# regenerated for 2.39
# Revision 1.21  2006/01/24 15:55:42  sds
# regenerated for clisp 2.38 release
# Revision 1.20  2006/01/02 17:09:36  sds
# regenerated for 2.37 (2006-01-02)
# Revision 1.19  2005/12/04 22:37:32  sds
# regenerated for clisp 2.36 release
# Revision 1.18  2005/08/29 18:18:56  sds
# regenerated
# Revision 1.17  2005/08/28 16:27:17  sds
# regenerated
# Revision 1.16  2005/07/20 23:58:29  sds
# clisp 2.34 (2005-07-20)
# Revision 1.15  2005/07/13 19:11:34  sds
# regenerated for 2.33.84
# Revision 1.14  2005/07/06 17:05:52  sds
# regenerated
# Revision 1.13  2005/06/27 15:30:42  sds
# regenerated
# Revision 1.12  2005/03/17 23:14:48  sds
# regenerated
# Revision 1.11  2005/02/16 22:30:56  haible
# Regenerated.
# Revision 1.10  2004/12/10 16:11:18  sds
# Based CLISP 2.33.80 (2004-11-27)
# Revision 1.9  2004/03/31 12:48:41  haible
# Update after change of format string convention: '~' -> '~S', '$' -> '~C'.
# Revision 1.8  2004/03/31 12:07:14  haible
# msgmerged.
# Revision 1.7  2004/03/31 11:52:39  haible
# Update for removal of leading and trailing newlines.
# Revision 1.6  2004/03/30 20:38:21  haible
# msgmerged.
# Revision 1.5  2004/03/17 20:47:07  sds
# regenerated for 2.33
# Revision 1.4  2004/03/14 17:27:54  sds
# regenerated for 2.32.94
# Revision 1.3  2004/03/12 19:22:47  sds
# regenerated for 2.32.93
# Revision 1.2  2002/09/13 15:00:36  sds
# regenerated for 2.30
# Revision 1.1  2002/05/18 14:27:46  sds
# kill src/gettext; POs are now in src/po
# Revision 1.1  2002/05/18 14:27:46  sds
# kill src/gettext; POs are now in src/po
# Revision 1.10  1998/09/07 18:21:38  clinares
# Traducción de todos los mensajes para la versión del 29-8-1998. Estos
# cambios, sin embargo, serán publicados en alguna nueva versión de
# septiembre de este mismo año.
# Revision 1.9  1997/09/18 13:36:38  clinares
# He incluído nuevas modificaciones de Leo Sarasúa.
# Entre las más representativas está el hecho de haber modificado
# `trama' por `marco' y `# macro carácter' por `macro carácter
# secundario'. Nuevamente gracias, Leo, ...
# Revision 1.8  1997/09/05 17:23:30  clinares
# He introducido todas las modificaciones propuestas por Santiago Vila a
# la versión 1.6. Además, las he adaptado para el nuevo .pot que se
# empleó en la versión 1.7.
# Entre los cambios más importantes está: `command' es `orden', no
# `comando'; `warning' es, preferiblemente, `atención' y, en otro caso,
# propongo que sea `advertencia', en vez de `aviso'.
# Revision 1.7  1997/09/03 17:51:44  clinares
# He modificado la traducción de las directivas ~SP, puesto que nunca se
# escribirán versiones en español de ellas, ya que el estándar Common
# Lisp - The Language es muy específico: solo en inglés. Ni en alemán,
# ni francés, ni español, ...
# Además, he adaptado los cambios del POT de la versión 1.6
# (POT-Creation-Date: 1997-05-04) a la última versión que existe
# actualmente (POT-Creation-Date: 1997-09-02). Para ello, he traducido 9
# mensajes nuevos, he corregido los mensajes difusos y he borrado todos
# los obsoletos.
# Revision 1.6  1997/08/30 14:04:08  clinares
# El 100% de los mensajes están traducidos :)
# En total, 9 meses de trabajo (es decir, aha sido un parto!! :)
# Revision 1.5  1997/08/27 00:48:46  clinares
# Esta es la traducción que resulta de programar todos los cambios
# propuestos por lsg (Leonardo Sarasúa García). En total, aalrededor de
# 800 líneas!!, ahí es nada :)
# Javier <fserrador@gmail.com>, 2018.
msgid ""
msgstr ""
"Project-Id-Version: Based CLISP 2.49.60\n"
"Report-Msgid-Bugs-To: clisp-devel@lists.sourceforge.net\n"
"POT-Creation-Date: 2017-06-25 11:29:03+0200\n"
"PO-Revision-Date: 2018-01-17 17:07+0100\n"
"Last-Translator: Francisco Javier Serrador <fserrador@gmail.com>\n"
"Language-Team: Spanish <es@tp.org.es>\n"
"Language: es\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"X-Generator: Poedit 1.8.7.1\n"
"X-Bugs: Report translation errors to the Language-Team address.\n"
"X-Poedit-SourceCharset: UTF-8\n"
"X-Project-Style: gnome\n"

# Vocavulario
# allocate: asignado
#   reallocate: reasignado
# "*** - desbordamiento de la pila del programa - REINICIALIZANDO" - lsg
# En mi opinión, RESET debe traducirse como un imperativo - cll
#: spvw.d:909
msgid "*** - Program stack overflow. RESET"
msgstr "*** - Sobredesbordamiento de la pila del programa. REINICIE"

# ¡ Toma puntilloso que soy! Lisp debería escribirse con mayúscula.
# "*** - desbordamiento de la pila de Lisp - REINICIALIZANDO" - lsg
#
# No, no, nada de REINICIALIZANDO. Debe ser un imperativo: REINICIE.
# Por ejemplo, si durante una sesión con CLisp haces:
#
# > (defun foo (a) (foo (1- a)))
# FOO
# > (foo 2)
#
# *** - Desbordamiento de la pila de Lisp. REINICIE
# >
#
# ..., pero el intérprete se queda esperando a que tú sigas tecleando,
# es decir, él solo no se pone a reiniciar nada, ...
#
# Por otra parte, tienes toda la razón, Lisp debe ir con mayúsculas :) - cll
#
#: spvw.d:924
msgid "*** - Lisp stack overflow. RESET"
msgstr "*** - Sobredesbordamiento de la pila de Lisp. REINICIE"

# ß¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:1190
msgid "Unknown FSUBR signature: %d %d %d\n"
msgstr ""
"Firma desconocida FSUBR: %d %d %d\n"
"\n"

# ß¿Tipo de argumento?? sv
#
# Claro, "tipo de argumento", es decir, "según sea el argumento". De
# todos modos, este mensaje está pendiente de remodelación. Ya he puesto
# un mensaje en la lista de clisp y en cuanto me respondan tal vez lo
# modifique. - cll
#
# En la lista de CLisp, Bruno Haible explicaba así qué es "FSUBR" y
# "SUBR":
#
# -----------------------
# This is very ancient Lisp terminology (1960ies). FSUBR means "special form".
# SUBR means "built-in/system function".
# -----------------------
#
# Por su parte, Joerg Hoehle explicaba: (atención al segundo párrafo)
#
# -----------------------
# They related to very old implementations of Lisp.  IIRC, SUBR
# (resp. FSUBR) served to recognize built-in functions (resp. special
# forms or macros) in the symbol-function slot of symbols, for example
# as (FSUBR <address>) so the Lisp interpreter knew it had to call an
# internal procedure and would not evaluate the arguments, whereas
# we all know (LAMBDA (#) ...).
#
# The term of "signature" is used like in finance or crime: a kind of
# characteristic of the function, and you know that when two signatures
# differ, the functions must differ (if they are the same, the functions
# need not be the same).  In CLISP, the signature of a function
# comprises / encodes the parameter list (number of required / optional
# parameters, &rest present and &key symbols).
# -----------------------
#
# A tenor de lo que se dice en la última de las frases, considero que la
# traducción actual (inspirada en la francesa) está bien, ¿sugerencias? - cll
#
#: spvw.d:1298
msgid "Unknown SUBR signature: %d %d %d %d"
msgstr "Firma desconocida SUBR: %d %d %d %d"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:2022
msgid "module '%s' requires package %s.\n"
msgstr "un módulo “%s” requiere un paquete %s.\n"

#
# "el módulo `%s' necesita el paquete %s.\n"
#
# Me parece más natural en español, aunque gramaticalmente no estaba
# mal. - lsg
#
# Pues si, tienes toda la razón del mundo - cll
#
#: spvw.d:2032
msgid "module '%s' redefines symbol "
msgstr "un módulo “%s” redefine un símbolo "

#: spvw.d:2034
msgid " in the locked package "
msgstr " dentro del paquete bloqueado "

# Sugerencia: definición de macro. sv
#
# Hmmm, ..., lo de macro definición es bastante típico en informática
# (ya sabes, ...) Sin embargo, en Lisp se suele decir definición de
# macro, tal y como tú propones, ..., pues vale, ¡sugerencia
# completamente aceptada! cll
#
#: spvw.d:2036
msgid ""
"\n"
"old definition: "
msgstr ""
"\n"
"definición anterior: "

#: spvw.d:2073
msgid "is an ANSI Common Lisp implementation."
msgstr "es una implementación ANSI Common Lisp."

#: spvw.d:2075
msgid ""
"This image does not process the usual command line arguments.\n"
"To create a normal image \"myclisp\", please do\n"
"%s --clisp-x '(ext:saveinitmem \"myclisp\" :executable t :init-function nil)'\n"
msgstr ""
"Esta imagen no procesa los argumentos de líneas de órdenes usuales.\n"
"Para crear una imagen común “myclisp”, por favor haga\n"
"%s --clisp-x '(ext:saveinitmem \"myclisp\" :executable t :init-function nil)'\n"

#: spvw.d:2080
msgid ""
"Usage:  %s [options] [lispfile [argument ...]]\n"
" When 'lispfile' is given, it is loaded and '*ARGS*' is set\n"
" to the list of argument strings. Otherwise, an interactive\n"
" read-eval-print loop is entered.\n"
msgstr ""
"Empleo:  %s [opciones] [lispfile [argumento ...]]\n"
" Cuando 'lispfile' está entregado, cargado y '*ARGS*' establecido\n"
" para la lista de cadenas de argumentos. En otro caso, se\n"
" introduce un bucle read-eval-print.\n"

#: spvw.d:2084
msgid "Informative output:"
msgstr "Salida informativa:"

#: spvw.d:2085
msgid " -h, --help    - print this help and exit"
msgstr "  -h,  --help    - enseña esta ayuda y finaliza"

#: spvw.d:2086
msgid " --version     - print the version information"
msgstr " --version       - enseña la información de la versión"

#: spvw.d:2087
msgid " --license     - print the licensing information"
msgstr " --license \t- enseña la información de la licencia"

#: spvw.d:2088
msgid " -help-image   - print image-specific help and exit"
msgstr " -help-image  - enseña la ayuda de imagen específica y termina"

#: spvw.d:2089
msgid "Memory image selection:"
msgstr "Seleccione la imagen de memoria:"

#: spvw.d:2090
msgid " -B lisplibdir - set the installation directory"
msgstr " -B lisplibdir - establece el directorio de la instalación"

#: spvw.d:2092
msgid " -K linkingset - use this executable and memory image"
msgstr " -K linkingset - emplee este ejecutable y memoria de imagen"

#: spvw.d:2094
msgid " -M memfile    - use this memory image"
msgstr " -M fichmem   - emplee esta imagen de memoria"

#: spvw.d:2095
msgid " -m size       - memory size (size = nB or nKB or nMB)"
msgstr " -m tamaño   - tamaño de memoria (tamaño = nB o nKB o nMB)"

#: spvw.d:2096
msgid "Internationalization:"
msgstr "Internacionalización:"

#: spvw.d:2097
msgid " -L language   - set user language"
msgstr " -L idioma      - establece el idioma del usuario"

#: spvw.d:2098
msgid " -N nlsdir     - NLS catalog directory"
msgstr "-N nlsdir       - directorio de catalogo NLS"

#: spvw.d:2099
msgid " -Edomain encoding - set encoding"
msgstr " -Edomain codificación - establece la codificación"

#: spvw.d:2100
msgid "Interoperability:"
msgstr "Interoperatividad:"

#: spvw.d:2101
msgid ""
" -q, --quiet, --silent, -v, --verbose - verbosity level:\n"
"     affects banner, *LOAD-VERBOSE*/*COMPILE-VERBOSE*,\n"
"     and *LOAD-PRINT*/*COMPILE-PRINT*"
msgstr ""
" -q, --quiet, --silent, -v, --verbose - nivel verboso:\n"
"      afecta banderas, *LOAD-VERBOSE*/*COMPILE-VERBOSE*,\n"
"     y *LOAD-PRINT*/*COMPILE-PRINT*"

#: spvw.d:2104
msgid " -w            - wait for a keypress after program termination"
msgstr " -w            - espera para una pulsación de tecla después de terminar el programa"

#: spvw.d:2105
msgid " -I            - be ILISP-friendly"
msgstr " -l             - ser ILISP-compatible"

#: spvw.d:2106
msgid " -disable-readline - do not use the gnu readline library"
msgstr " -disable-readline - no emplear la biblioteca readline de gnu"

#: spvw.d:2107
msgid "Startup actions:"
msgstr "Operaciones de inicio:"

#: spvw.d:2108
msgid " -ansi         - more ANSI CL compliance"
msgstr " -ansi        - más compatibilidad con ANSI CL"

#: spvw.d:2109
msgid " -traditional  - traditional (undoes -ansi)"
msgstr " -traditional  - tradicional (deshace -ansi)"

#: spvw.d:2110
msgid " -modern       - start in a case-sensitive lowercase-preferring package"
msgstr " -modern        - comienza en un paquete mayúsculas distinguibles prefiriendo minúsculas"

#: spvw.d:2111
msgid " -p package    - start in the package"
msgstr " -p paquete     - comienza en el paquete"

#: spvw.d:2112
msgid " -C            - set *LOAD-COMPILING* to T"
msgstr " -C            - establece *LOAD-COMPILING* a T"

#: spvw.d:2113
msgid " -norc         - do not load the user ~/.clisprc file"
msgstr " -norc         - no cargar el fichero del usuario ~/.clisprc"

#: spvw.d:2114
msgid " -lp dir       - add dir to *LOAD-PATHS* (can be repeated)"
msgstr " -lp dir       - añadir directorio a *LOAD-PATHS* (puede repetirse)"

#: spvw.d:2115
msgid " -i file       - load initfile (can be repeated)"
msgstr " -i file       - carga fichero de inicialización initfile (puede repetirse)"

#: spvw.d:2116
msgid "Actions:"
msgstr "Operaciones:"

#: spvw.d:2117
msgid " -c [-l] lispfile [-o outputfile] - compile lispfile"
msgstr " -c [-l] ficherolisp [-o ficherosalida] - complila fichero de lisp"

#: spvw.d:2118
msgid " -x expressions - execute the expressions, then exit"
msgstr " -x expresiones - ejecuta las expresiones, después termina"

#: spvw.d:2119
msgid " Depending on the image, positional arguments can mean:"
msgstr " Dependiendo en la imagen, argumentos posicionales pueden significar:"

#: spvw.d:2120
msgid "   lispscript [argument ...] - load script, then exit"
msgstr "    listscript [argumento ...] - carga script, después termina"

#: spvw.d:2121
msgid "   [argument ...]            - run the init-function"
msgstr "   [argumento ...]           - ejecuta la función init-function"

#: spvw.d:2122
msgid "  arguments are placed in EXT:*ARGS* as strings."
msgstr "  argumentos son colocados en EXT:*ARGS* como cadenas."

#: spvw.d:2123
msgid "These actions put CLISP into a batch mode, which is overridden by"
msgstr "Estas operaciones ponen a CLISP dentro de un modo de batch, el cual es sobreconducido por"

#: spvw.d:2124
msgid " -on-error action - action can be one of debug, exit, abort, appease"
msgstr " -on-error operación - operación puede ser una de depuración, salida, aborto, agrego"

#: spvw.d:2125
msgid " -repl            - enter the interactive read-eval-print loop when done"
msgstr " -repl            - introduce el bucle interactivo read-eval-print cuando termine"

#: spvw.d:2126
msgid "Default action is an interactive read-eval-print loop."
msgstr "Operación predeterminada es un bucle interactivo read-eval-print."

#: spvw.d:2135
msgid "%s: use '-h' for help"
msgstr "%s: emplee ‘-h’ para ayuda                         Escribe esta ayuda, después finaliza"

# ¿Por qué no inválido? La palabra existe.
# Un día os tengo que enviar un trozo de "1984" de Orwell,
# que habla de "neolengua", el único idioma del mundo que tiene
# cada vez menos palabras, en vez de más... sv
#
# a¡Por supuestísimo!!! Tienes toda la razón del mundo. De hecho, si
# echas un ojo al resto de los mensajes verás que yo siempre he
# traducido "invalid" por "inválido" salvo en tres ocasiones: en dos
# preferí la expresión "no es correcto" y en la otra lo dejé como "no es
# válido" en vez de "no válido" que, además, suena horrible.
#
# A propósito del trozo de "1984", venga, ya estoy esperando :) - cll
#
#: spvw.d:2139
msgid "invalid argument"
msgstr "argumento no válido"

#: spvw.d:2450
msgid "Syntax for %s: nnnnnnn or nnnnKB or nMB"
msgstr "Sintaxis de %s: nnnnnnn o nnnnKB o nMB"

#: spvw.d:2456
msgid "warning: %s %lu too small, using %lu instead"
msgstr "advertencia: %s %lu demasiado pequeño, empleando %lu en su lugar"

#: spvw.d:2462
msgid "warning: %s %lu too large, using %lu instead"
msgstr "advertencia: %s %lu demasiado largo, empleando en su lugar %lu"

#: spvw.d:2618
msgid "memory size"
msgstr "tamaño de memoria"

#: spvw.d:2644
msgid "multiple -B"
msgstr "-B múltiple"

#: spvw.d:2652
msgid "This option requires an argument"
msgstr "Esta opción requiere un argumento"

#: spvw.d:2689
msgid "-E requires an argument"
msgstr "-E requiere un argumento"

#: spvw.d:2924
msgid "-l without -c is invalid"
msgstr "-l sin -c no es válido"

# Duda: En este mensaje, el primer "~S" se sustituye por el nombre de una
# función y el segundo "~S" sobre el nombre de un flujo (stream). Por
# eso, este mensaje quedaría, mas o menos, de la manera:
#
# <función> no es posible sobre el flujo <flujo>
#
# ¿os gusta o lo encontrais raro?
#
#: spvw.d:2930
msgid "-x with -c is invalid"
msgstr "-x con -c es no válido"

#: spvw.d:2935
msgid "-x with lisp-file is invalid"
msgstr "-x con fichero-lisp no es válido"

#: spvw.d:3079
msgid "Return value of malloc() = %lx is not compatible with type code distribution."
msgstr "Valor devuelto por malloc() = %lx no es compatible con la distribución del código de tipo."

# solo es con acento.
# "sólo %d bytes disponibles\n" - lsg
#
# aMadre mía!! Tienes toda la razón del mundo - cll :)
#
#: spvw.d:3086
msgid "Only %ld bytes available."
msgstr "Sólo quedan %ld bytes disponibles."

# Duda: Imagino que SP es el "Stack Pointer". Pero entonces, ¿a qu
# viene decir "SP stack"? ¿Se referirán con ello a la pila del sistema?
# - cll
#
#: spvw.d:3321
msgid "Could not determine the end of the SP stack!"
msgstr "No fue posible determinar el final de la pila SP!"

#: spvw.d:4060
msgid "%s: Not enough memory for Lisp."
msgstr "%s: no hay memoria suficiente para Lisp."

# "*** - Memoria virtual agotada. REINICIALIZACION " - lsg
#
# Yo creo que el mensaje debe acabar en un imperativo: REINICIALIZAR - cll
#
#: spvw_alloca.d:48
msgid "*** - Virtual memory exhausted. RESET"
msgstr "*** - Memoria virtual agotada. REINICIE"

# "*** - Memoria agotada. REINICIALIZACION " - lsg
#
# Más de lo mismo - cll
#
#: spvw_alloca.d:50
msgid "*** - Memory exhausted. RESET"
msgstr "*** - Memoria agotada. REINICIE"

#: spvw_mmap.d:105
msgid "Warning: overwriting existing memory mappings in the address range 0x%lx...0x%lx. clisp will likely crash soon!!\n"
msgstr "Advertencia: sobrescribiendo desglose de memoria en el rango de dirección 0x%lx...0x%lx. ¡¡clisp explotará pronto!!\n"

#: spvw_mmap.d:161
msgid "Warning: reserving address range 0x%lx...0x%lx that contains memory mappings. clisp might crash later!\n"
msgstr "Advertencia: reservando rango de direcciones 0x%lx...0x%lx que contiene distribuciones de memoria. clisp puede romperse más tarde!\n"

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:203 spvw_mmap.d:323 spvw_mmap.d:496
msgid "Cannot map memory to address 0x%lx ."
msgstr "No se puede asignar la memoria a la dirección 0x%lx ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:296
msgid "Cannot reserve address range at 0x%lx ."
msgstr "No se puede reservar el rango de direcciones en 0x%lx ."

# No me gusta demasiado lo de mapear, pero qué se le va a hacer, salvo
# añadir el acento que faltaba. ;-)
#
# "no se puede mapear la memoria a la dirección 0x%x ." - lsg
#
# Al final, siguiendo las recomendaciones de la lista "spanglish.txt",
# he preferido traducir `map' por `asignar'.
#
# Y desde luego, respecto del acento tienes toda la razón del mundo - cll
#
#: spvw_mmap.d:306
msgid "Cannot reserve address range 0x%lx-0x%lx ."
msgstr "No se puede reservar el rango de direcciones 0x%lx-0x%lx ."

#: spvw_mmap.d:350
msgid "CreateFileMapping() failed."
msgstr "CreateFileMapping() falló."

#: spvw_mmap.d:358
msgid "MapViewOfFileEx(addr=0x%x,off=0x%x) failed."
msgstr "MapViewOfFileEx(dirección=0x%x,segmento=0x%x) falló."

#: spvw_mmap.d:364
msgid "MapViewOfFileEx() returned 0x%x instead of 0x%x."
msgstr "MapViewOfFileEx() devolvió 0x%x en vez de 0x%x."

#: spvw_mmap.d:379
msgid "VirtualFree() failed."
msgstr "VirtualFree() fallado."

#: spvw_mmap.d:393
msgid "VirtualProtect() failed."
msgstr "VirtualProtect() fallado."

#: spvw_mmap.d:460
msgid "Cannot open <%s>."
msgstr "No se puede abrir <%s>."

#: spvw_fault.d:285
msgid "mprotect(0x%lx,%d,%d) failed."
msgstr "mprotect(0x%lx,%d,%d) fallado."

#: spvw_sigsegv.d:25
msgid "GC count: %lu"
msgstr "Contado GC: %lu"

# collect → recoger
#: spvw_sigsegv.d:27
msgid "Space collected by GC:"
msgstr "Espacio recogido por GC:"

#: spvw_sigsegv.d:41
msgid "Run time:"
msgstr "Tiempo de ejecución:"

#: spvw_sigsegv.d:43
msgid "Real time:"
msgstr "Hora real:"

#: spvw_sigsegv.d:45
msgid "GC time:"
msgstr "Tiempo GC:"

#: spvw_sigsegv.d:48
msgid "Permanently allocated: %lu bytes."
msgstr "Permanentemente asignados: %lu bytes."

#: spvw_sigsegv.d:51
msgid "Currently in use: %lu bytes."
msgstr "Actualmente empleados: %lu bytes."

#: spvw_sigsegv.d:54
msgid "Free space: %lu bytes."
msgstr "Espacio libre: %lu bytes."

# "SIGSEGV no puede ser subsanado. Dirección del error =3D 0x%x.\n" - lsg
#
# Si, me gusta más tu traducción. Yo había puesto:
#
# "No se puede evitar SIGSEGV. Dirección de fallo = 0x%x.\n"
#
# Pero el caso es que un SIGSEGV no tiene porque evitarse puesto que es
# una señal que, para cuando sale este mensaje, ya se ha recibido. El
# problema ---realmente--- es que no fue posible "subsanar" la
# señal. Muy bien - cll
#
# De todas formas, prefiero ponerlo al revés ("No se puede subsanar" en
# vez de "... no puede ser subsanado"). Por otra parte, en vez de
# "error" prefiero "fallo" puesto que eso es exactamente de lo que se
# trata. No de un error por algo que alguien hizo mal, sino de un fallo
# del sistema, ... - cll
#
#: spvw_sigsegv.d:65
msgid "SIGSEGV cannot be cured. Fault address = 0x%lx."
msgstr "SIGSEGV no se puede subsanar Dirección fallada = 0x%lx."

#: spvw_sigsegv.d:180
msgid "Apollo 13 scenario: Stack overflow handling failed. On the next stack overflow we will crash!!!"
msgstr "Escenario Apollo 13: manipulación de sobredesbordamiento de pila. ¡¡¡ Nos estrellaremos en el siguiente desbordamiento de pila !!!"

#: spvw_garcol.d:2563 spvw_garcol_old.d:1981
msgid "munmap() failed."
msgstr "munmap() fallado."

#
# "*** - no queda espacio para almacenar objetos LISP - REINICIALIZANDO" - lsg
#
# Yo sigo en mis trece, ... Debe ser un imperativo: REINICIE - cll
#
#: spvw_allocate.d:103
msgid "*** - No more room for LISP objects: RESET"
msgstr "*** - No queda espacio para almacenar más objetos LISP: REINICIE"

#: spvw_allocate.d:314 spvw_allocate.d:373 spvw_allocate.d:456
msgid "Trying to make room through a GC..."
msgstr "Intentando obtener más espacio a través de un GC..."

#
# "error del sistema operativo al cargar el fichero de inicialización `%s'\n" - lsg
#
# Así dicho parece que la culpa ha sido la carga del fichero de
# inicialización, cuando en realidad, el mensaje dice "durante". El
# error puede haber sido algo distinto de la carga. Por ejemplo, la
# carga puede ser correcta pero puede no cargarse en memoria (se me
# ocurre así de pronto), o cualquier otra cosa. Por eso prefiero la
# traducción:
#
# "error del sistema operativo durante la carga del fichero de inicialización `%s'\n"
#
# - cll
#
#: spvw_memfile.d:991 spvw_memfile.d:1847
msgid "%s: operating system error during load of initialization file `%s'"
msgstr "%s: error del sistema operativo durante carga del fichero de inicialización `%s'"

#: spvw_memfile.d:1512
msgid "%s: Cannot map the initialization file `%s' into memory."
msgstr "%s: No puedo distribuir el fichero ‘%s’ de inicialización dentro de memoria."

#: spvw_memfile.d:1852
msgid "%s: initialization file `%s' was not created by this version of CLISP runtime"
msgstr "%s: fichero ‘%s’ de inicialización no ha sido creado con esta versión CLISP de tiempo de ejecución"

#: spvw_memfile.d:1856
msgid "%s: not enough memory for initialization"
msgstr "%s: no hay memoria suficiente para inicialización."

#: spvw_memfile.d:1906
msgid "%s: 'image size' method failed, but found image header at %d\n"
msgstr "%s: método de 'tamaño de imagen' ha fallado, pero cabecera de imagen encontrada en %d\n"
